app.py

routes/login_routes.py
routes/user_routes.py
routes/interdicoes_routes.py

models/login.py
models/user.py
models/interdicoes.py


app.py
from flask import Flask
import werkzeug
from routes.user_routes import user_routes
from routes.interdicoes_routes import interdicoes_routes
from routes.login_routes import login_routes
from models.user import Usuario
from models.interdicoes import Interdicoes


app = Flask(__name__)
app.register_blueprint(user_routes)
app.register_blueprint(interdicoes_routes)
app.register_blueprint(login_routes)

def create_tables():
    # Cria as tabelas se elas não existirem
    Usuario.create_table()
    Interdicoes.create_table()

    # Comente a linha abaixo se não desejar excluir as tabelas ao iniciar o aplicativo
    # Usuario.drop_table()
    # Interdicoes.drop_table()

create_tables()

@app.errorhandler(werkzeug.exceptions.BadRequest)
def handle_bad_request(e: Exception):
    return str(e), 400

@app.errorhandler(werkzeug.exceptions.NotFound)
def handle_notfound_request(e: Exception):
    return str(e), 404

@app.errorhandler(werkzeug.exceptions.Unauthorized)
def handle_unauthorized_request(e: Exception):
    return str(e), 401

if __name__ == '__main__':
    app.run(port=8000, debug=True)

routes/login_routes.py
from flask import Blueprint, request, jsonify
import bcrypt
import jwt
import datetime
from models.user import Usuario

login_routes = Blueprint('login_routes', __name__)

SECRET_KEY = 'asjaojaodvjado'

@login_routes.route('/login', methods=['POST'])
def login():
    data = request.json
    cpf = data.get('cpf')
    senha = data.get('senha')

    if cpf and senha:
        usuario = Usuario.buscar_por_cpf(cpf)
        if usuario and bcrypt.checkpw(senha.encode('utf-8'), usuario.senha.encode('utf-8')):
            payload = {'cpf': cpf, 'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1)}
            token = jwt.encode(payload, SECRET_KEY, algorithm='HS256')
            return jsonify({'token': token}), 200

    return jsonify({'message': 'Invalid credentials'}), 401


routes/user_routes.py
from flask import Blueprint, request
import werkzeug
from models.user import Usuario
from middleware import token_required

user_routes = Blueprint('user_routes', __name__)

@user_routes.route('/users', methods=['POST'])
def criar_usuario():
    dados = request.json
    novo_usuario = Usuario.criar(dados)
    if novo_usuario:
        return 'Usuário criado com sucesso!', 201
    else:
        raise werkzeug.exceptions.BadRequest('Erro ao criar usuário, verifique os dados inseridos.')

@user_routes.route('/users/<cpf>', methods=['GET'])
@token_required
def buscar_usuario(cpf):
    usuario = Usuario.buscar_por_cpf(cpf)
    if usuario:
        return {
            'nome': usuario.nome,
            'sobrenome': usuario.sobrenome,
            'cpf': usuario.cpf,
            'whatsapp': usuario.whatsapp,
            'email': usuario.email,
            'cep': usuario.cep,
            'logradouro': usuario.logradouro,
            'numero': usuario.numero,
            'bairro': usuario.bairro,
            'complemento': usuario.complemento,
            'cidade': usuario.cidade,
            'estado': usuario.estado
        }, 200
    else:
        raise werkzeug.exceptions.NotFound('Usuário não encontrado')

@user_routes.route('/users/<cpf>', methods=['PUT'])
@token_required
def atualizar_usuario(cpf):
    dados = request.json
    usuario_atualizado = Usuario.alterar(cpf, dados)
    if usuario_atualizado:
        return 'Usuário atualizado com sucesso', 200
    else:
        raise werkzeug.exceptions.NotFound('Não foi possivél prosseguir com a atualização dos dados do usuário.')

@user_routes.route('/users/<cpf>', methods=['DELETE'])
@token_required

def deletar_usuario(cpf):
    Usuario.deletar(cpf)
    return 'Usuário deletado com sucesso', 200


routes/interdicoes_routes.py
from flask import Blueprint, request, jsonify
import werkzeug
from models.interdicoes import Interdicoes
from middleware import token_required

interdicoes_routes = Blueprint('interdicoes_routes', __name__)

@interdicoes_routes.route('/interdicoes', methods=['POST'])
@token_required
def criar_interdicao():
    dados = request.json
    nova_interdicao = Interdicoes.criar(**dados)
    if nova_interdicao:
        return 'Interdição criada com sucesso!', 201
    else:
        raise werkzeug.exceptions.BadRequest('Erro ao criar interdição.')

@interdicoes_routes.route('/interdicoes/<tipo>', methods=['GET'])
@token_required
def buscar_interdicoes_por_tipo(tipo):
    interdicoes = Interdicoes.buscar_por_tipo(tipo)
    if interdicoes:
        return jsonify({'interdicoes': [interdicao.serialize() for interdicao in interdicoes]}), 200
    else:
        raise werkzeug.exceptions.NotFound(f'Não há interdições cadastradas com o tipo {tipo}')

@interdicoes_routes.route('/interdicoes', methods=['GET'])
@token_required
def listar_interdicoes():
    interdicoes = Interdicoes.listar()
    if interdicoes:
        return jsonify({'interdicoes': [interdicao.serialize() for interdicao in interdicoes]}), 200
    else:
        raise werkzeug.exceptions.NotFound('Não há interdições cadastradas.')

@interdicoes_routes.route('/interdicoes/<interdicao_id>', methods=['DELETE'])
@token_required
def deletar_interdicao(interdicao_id):
    Interdicoes.deletar(interdicao_id)
    return 'Interdição deletada com sucesso', 200


models/login.py
import bcrypt
from models.user import Usuario
import jwt
import datetime
from flask import Flask, request, jsonify

app = Flask(__name__)

# Configuração da chave secreta para o JWT
SECRET_KEY = 'asjaojaodvjado'

class Autenticacao:
    @staticmethod
    def generate_token(username):
        payload = {
            'username': username,
            'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1)
        }
        token = jwt.encode(payload, SECRET_KEY, algorithm='HS256')
        return token

    @staticmethod
    def validate_token(token):
        try:
            decoded_token = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])
            return decoded_token
        except jwt.ExpiredSignatureError:
            return None
        except jwt.InvalidTokenError:
            return None

    @staticmethod
    def login(username, password):
        user = Usuario.get(username)
        if user and bcrypt.checkpw(password.encode('utf-8'), user.senha.encode('utf-8')):
            return user
        else:
            return None

@app.route('/login', methods=['POST'])
def login_route():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')

    token = Autenticacao.login(username, password)
    if token:
        return jsonify({'token': token})
    else:
        return jsonify({'message': 'Invalid credentials'}), 401

@app.route('/protected', methods=['GET'])
def protected():
    token = request.headers.get('Authorization')
    if not token:
        return jsonify({'message': 'Token is missing'}), 401

    token = token.split(" ")[1]  # Remove o prefixo "Bearer "

    decoded_token = Autenticacao.validate_token(token)
    if decoded_token:
        return jsonify({'message': f'Welcome {decoded_token["username"]}!'})
    else:
        return jsonify({'message': 'Invalid token'}), 401

if __name__ == '_main_':
    app.run(debug=True)

models/user.py
import bcrypt
import peewee
from peewee import DoesNotExist
from uuid import uuid4

import werkzeug
from config import BaseModel

class Usuario(BaseModel):
    id = peewee.UUIDField(primary_key=True, default=uuid4)
    nome = peewee.CharField()
    sobrenome = peewee.CharField()
    cpf = peewee.CharField(unique=True, max_length=11)
    whatsapp = peewee.CharField()
    email = peewee.CharField(unique=True)
    senha = peewee.CharField()
    cep = peewee.CharField(max_length=8)
    logradouro = peewee.CharField()
    numero = peewee.CharField()
    bairro = peewee.CharField()
    complemento = peewee.CharField()
    cidade = peewee.CharField()
    estado = peewee.CharField()

    @classmethod
    def criar(cls, dados):
        if len(dados['senha']) < 6:
          print('Erro: A senha precisa ter pelo menos 6 caracteres')
          return None
        
        if cls.select().where(cls.cpf == dados['cpf']).exists():
          print(f'Erro: Já existe um usuário com o CPF "{dados['cpf']}"')
          return None
        
        hashed_password = bcrypt.hashpw(dados['senha'].encode('utf-8'), bcrypt.gensalt())
        dados['senha'] = hashed_password.decode('utf-8')

        novo_usuario = cls.create(**dados)
        return novo_usuario
        
    @classmethod
    def buscar_por_cpf(cls, user_cpf):
        try:
            usuario = cls.get(cls.cpf == user_cpf)
            return usuario
        
        except DoesNotExist:
          raise werkzeug.exceptions.NotFound(f'Usuário não encontrado')


    @classmethod
    def alterar(cls, user_cpf, dados):
      try:
          usuario = Usuario.get(Usuario.cpf == user_cpf)

          if 'whatsapp' in dados:
              usuario.whatsapp = dados['whatsapp']
          if 'cep' in dados:
              usuario.cep = dados['cep']
          if 'logradouro' in dados:
              usuario.logradouro = dados['logradouro']
          if 'numero' in dados:
              usuario.numero = dados['numero']
          if 'bairro' in dados:
              usuario.bairro = dados['bairro']
          if 'complemento' in dados:
              usuario.complemento = dados['complemento']
          if 'cidade' in dados:
              usuario.cidade = dados['cidade']
          if 'estado' in dados:
              usuario.estado = dados['estado']

          usuario.save()
          return usuario
      
      except DoesNotExist:
          raise werkzeug.exceptions.NotFound(f'Usuário com ID {user_cpf} não encontrado.')

        
    @classmethod
    def listar(cls, cpf):
        usuario_entity = cls.buscar_por_cpf(cpf)

        if usuario_entity:
            print('Usuário encontrado:')
            print(f'Nome: {usuario_entity.nome} {usuario_entity.sobrenome}')
            print(f'Email: {usuario_entity.email}')
            print(f'Whatsapp: {usuario_entity.whatsapp}')
            print(f'CEP: {usuario_entity.cep}')
            print(f'Logradouro: {usuario_entity.logradouro}')
            print(f'Número: {usuario_entity.numero}')
            print(f'Bairro: {usuario_entity.bairro}')
            print(f'Cidade: {usuario_entity.cidade}')
            print(f'Estado: {usuario_entity.estado}')
        else:
            raise werkzeug.exceptions.NotFound('Usuário não encontrado')

    @classmethod
    def deletar(cls, user_cpf):
        try:
            usuario = cls.get(cls.cpf == user_cpf)
            usuario.delete_instance()
            print(f"Usuário com ID {user_cpf} deletado com sucesso.")
        
        except DoesNotExist:
          raise werkzeug.exceptions.BadRequest(f'Usuário {user_cpf} não encontrado.')



models/interdicoes.py

import peewee
from peewee import ForeignKeyField
from uuid import uuid4

import werkzeug
from config import BaseModel
from models.user import Usuario

class Interdicoes(BaseModel):
  id = peewee.UUIDField(primary_key=True, default=uuid4)
  tipo = peewee.CharField()
  cep = peewee.CharField(max_length=8)
  logradouro = peewee.CharField()
  numero = peewee.CharField()
  bairro = peewee.CharField()
  cidade = peewee.CharField()
  estado = peewee.CharField()
  data = peewee.DateField()
  descricao = peewee.CharField()
  usuario = ForeignKeyField(Usuario, backref='eventos')

  def serialize(self):
    usuario_data = None
    if self.usuario:
        usuario_data = {
            'id': str(self.usuario.id),
            'nome': self.usuario.nome,
            'sobrenome': self.usuario.sobrenome,
            'cpf': self.usuario.cpf,
            'whatsapp': self.usuario.whatsapp,
            'email': self.usuario.email,
            # Adicione mais campos do usuário conforme necessário
        }
    
    return {
        'id': str(self.id),
        'usuario': usuario_data,
        'tipo': self.tipo,
        'descricao': self.descricao,
        'data_inicio': self.data_inicio.strftime('%Y-%m-%d %H:%M:%S'),
        'data_fim': self.data_fim.strftime('%Y-%m-%d %H:%M:%S') if self.data_fim else None,
        # Adicione outros campos da interdição aqui
    }

  @classmethod
  def criar(cls, tipo, cep, logradouro, numero, bairro, cidade, estado, data, descricao, usuario):

    if not tipo or not cep or not logradouro or not numero or not bairro or not cidade or not estado or not data or not descricao or not usuario:
      raise werkzeug.exceptions.BadRequest(f'Erro: Todos os campos obrigatórios devem ser preenchidos.')

    
    try:
      nova_interdicao = cls.create(
        tipo = tipo,
        cep = cep,
        logradouro = logradouro,
        numero = numero,
        bairro = bairro,
        cidade = cidade,
        estado = estado,
        data = data,
        descricao = descricao,
        usuario = usuario
      )

      print('Interdição criada com sucesso!')
      return nova_interdicao
    
    except Exception as e:
      raise werkzeug.exceptions.BadRequest('Erro ao criar interdição.')
      

  @classmethod
  def buscar_por_tipo(cls, tipo):
    interdicoes_por_tipo = cls.select().where(cls.tipo == tipo)
    return interdicoes_por_tipo

  @classmethod
  def listar(cls):
    return list(cls.select().order_by(cls.data.desc()))

  @classmethod
  def deletar(cls, interdicao_id):
    try:
      interdicao = cls.get_by_id(interdicao_id)
      interdicao.delete_instance()
      print(f'Interdição com ID {interdicao_id} deletada com sucesso.')

    except cls.DoesNotExist:
      raise werkzeug.exceptions.NotFound('Interdição com ID {interdicao_id} não encontrada.')


  def serialize(self):
    return {
      'id': str(self.id),
      'tipo': self.tipo,
      'cep': self.cep,
      'logradouro': self.logradouro,
      'numero': self.numero,
      'bairro': self.bairro,
      'cidade': self.cidade,
      'estado': self.estado,
      'data': self.data.isoformat(),
      'descricao': self.descricao,
      'usuario_id': str(self.usuario.id)
    }


Tenho erro ao acessar as rotas abaixo:

@interdicoes_routes.route('/interdicoes/<tipo>', methods=['GET'])
@token_required
def buscar_interdicoes_por_tipo(tipo):
___
@interdicoes_routes.route('/interdicoes', methods=['GET'])
@token_required
def listar_interdicoes():
___
@interdicoes_routes.route('/interdicoes/<interdicao_id>', methods=['DELETE'])
@token_required
def deletar_interdicao(interdicao_id):

## O ERRO:

127.0.0.1 - - [21/May/2024 13:55:05] "POST /login HTTP/1.1" 200 -
127.0.0.1 - - [21/May/2024 13:55:05] "GET /interdicoes HTTP/1.1" 500 -
Traceback (most recent call last):
  File "/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/peewee.py", line 7270, in get
    return clone.execute(database)[0]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/peewee.py", line 4570, in __getitem__
    return self.row_cache[item]
           ^^^^^^^^^^^^^^^^^^^^
IndexError: list index out of range

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/flask/app.py", line 1498, in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/flask/app.py", line 1476, in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/flask/app.py", line 1473, in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/flask/app.py", line 882, in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/flask/app.py", line 880, in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/flask/app.py", line 865, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/taianekarine/Documents/dev/mais1Code/backend-resilience/middleware.py", line 53, in decorated
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
  File "/Users/taianekarine/Documents/dev/mais1Code/backend-resilience/routes/interdicoes_routes.py", line 32, in listar_interdicoes
    return jsonify({'interdicoes': [interdicao.serialize() for interdicao in interdicoes]}), 200
                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/taianekarine/Documents/dev/mais1Code/backend-resilience/models/interdicoes.py", line 105, in serialize
    'usuario_id': str(self.usuario.id)
                      ^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/peewee.py", line 4717, in __get__
    return self.get_rel_instance(instance)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/peewee.py", line 4708, in get_rel_instance
    obj = self.rel_model.get(self.field.rel_field == value)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/peewee.py", line 6822, in get
    return sq.get()
           ^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/peewee.py", line 7273, in get
    raise self.model.DoesNotExist('%s instance matching query does '
models.user.UsuarioDoesNotExist: <Model: Usuario> instance matching query does not exist:
SQL: SELECT "t1"."id", "t1"."nome", "t1"."sobrenome", "t1"."cpf", "t1"."whatsapp", "t1"."email", "t1"."senha", "t1"."cep", "t1"."logradouro", "t1"."numero", "t1"."bairro", "t1"."complemento", "t1"."cidade", "t1"."estado" FROM "usuario" AS "t1" WHERE ("t1"."id" = ?) LIMIT ? OFFSET ?
Params: ['20148f51c6414f239a03ade40f4c69d5', 1, 0]
127.0.0.1 - - [21/May/2024 13:55:06] "GET /interdicoes?__debugger__=yes&cmd=resource&f=style.css HTTP/1.1" 304 -
127.0.0.1 - - [21/May/2024 13:55:06] "GET /interdicoes?__debugger__=yes&cmd=resource&f=debugger.js HTTP/1.1" 304 -
127.0.0.1 - - [21/May/2024 13:55:06] "GET /interdicoes?__debugger__=yes&cmd=resource&f=console.png HTTP/1.1" 304 -
